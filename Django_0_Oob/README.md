# Oob
## - ex00: Resume Generator
This tool is designed to convert a `.template` file into an `.html` file by replacing placeholders with values defined in a settings.py file. This script reads the `.template` file, performs substitutions based on the settings, and writes the output to an `.html` file.

### Objective
- `Create a Python script`: Develop a render.py program to handle the conversion of template files to HTML.
- `Replace Placeholders`: The script will use values defined in a settings.py file to replace placeholders in the .template file.
- `Error Handling`: Ensure the script correctly handles errors such as incorrect file extensions, non-existing files, and wrong number of arguments.

### Instructions
1. File Handling:
- The `render.py` script should handle input and output file operations.
- Check if the file extension is `.template` and handle cases where the file does not exist.
2. Placeholder Replacement:
- Read the content of the `.template` file.
- Replace placeholders with corresponding values from `settings.py`.
3. Output Generation:
- Write the result to a new `.html` file, generated by replacing the .template extension with `.html`.
4. Error Messages:
- Provide appropriate messages for errors, including usage instructions, incorrect file types, and missing files.

### Example Usage
To run the script and generate an HTML file, use the following command:
```
python3 render.py file.template

```
This command will read `file.template`, apply the replacements using values from `settings.py`, and create a `file.html` with the processed content.

### Learning Points
- `File I/O`: Understand how to handle file operations, including reading from and writing to files.
- `String Replacement`: Learn to replace placeholders in a template with dynamic values.
- `Error Handling`: Gain experience in managing various error scenarios and providing user feedback.

By completing this exercise, you will gain experience in file operations, string manipulation, and error handling in Python.

## - ex01: Intern and Coffee Classes
In this exercise, you will create two Python classes: `Intern` and `Coffee`. The `Intern` class simulates an intern who has a name and can perform certain actions, while the `Coffee` class represents a coffee with a specific description. You will implement functionality to manage an intern's name, simulate making coffee, and handle exceptions for unsupported tasks.

### Objective
- `Create the Intern Class`: Define a class that manages an intern's name and includes methods for performing actions.
- `Create the Coffee Class`: Implement a nested class within Intern that simulates a coffee with a specific description.
- `Exception Handling`: Implement error handling to manage unsupported actions performed by the intern.

### Instructions
1. Intern Class:
- Implement a constructor (`__init__`) to initialize the intern's name with a default value if no name is provided.
- Implement a method `builder(name)` to assign a new name to the intern.
- Implement a `__str__()` method to return the intern's name.
- Implement a method `work()` that raises an exception with the message "I’m just an intern, I can’t do that...".
- Implement a method `make_coffee()` that returns an instance of the `Coffee` class.
2. Coffee Class:
- Implement a `__str__()` method to return the description "This is the worst coffee you ever tasted."
3. Testing:
- Instantiate the `Intern` class twice: once without a name and once with the name "Mark".
- Display the names of both instances.
- Ask the intern named "Mark" to make coffee and display the result.
- Ask the other intern to work and handle the exception appropriately.

### Example Usage
When running the `intern()` function from the `intern.py` script:
- You will see the name of each intern displayed.
- The intern named "Mark" will be able to make coffee, and the output will display the coffee description.
- The other intern will raise an exception when asked to work, which will be handled and displayed.

### Learning Points
- `Class Definition`: Learn how to define and use classes in Python, including nested classes.
- `Method Implementation`: Understand how to implement and use various methods within a class.
- `Exception Handling`: Practice handling exceptions that occur during method execution.

By completing this exercise, you will gain experience in defining and using classes, managing class methods, and handling exceptions effectively.

## - ex02: Beverage Classes
In this exercise, you will create a base class `HotBeverage` and several derived classes representing specific types of beverages. The `HotBeverage` class will define common attributes and methods, while the derived classes will override these attributes to specify their unique characteristics.

### Objective
- `Create the HotBeverage Class`: Define a base class with default attributes and methods for a hot beverage.
- `Create Derived Classes`: Implement specific beverage classes (`Coffee`, `Tea`, `Chocolate`, `Cappuccino`) that inherit from `HotBeverage` and override the necessary attributes.
- `Instance Representation`: Ensure each class provides a proper string representation of its instances.

### Instructions
1. HotBeverage Class:
- Define a class `HotBeverage` with the following attributes:
```
price: 0.30
name: "hot beverage"
description: "Just some hot water in a cup."
```
- Implement a `describe()` method that returns the description of the beverage.
- Implement a `__str__()` method that returns the instance's attributes in the format:
```
name : <name attribute>
price : <price attribute limited to two decimal points>
description : <instance's description>
```
2. Derived Classes: `Coffee`, `Tea`, `Chocolate`, `Cappuccino`
- Ensure that each derived class only redefines the attributes that are different from the base class `HotBeverage`.

### Example Usage
When running the `beverages()` function from the `beverages.py` script:
- Create instances of `HotBeverage`, `Coffee`, `Tea`, `Chocolate`, and Cappuccino.
- Print each instance to display their attributes.

### Learning Points
- `Class Inheritance`: Learn how to use inheritance to create specialized classes from a base class.
- `Method Overriding`: Understand how to override methods and attributes in derived classes to customize behavior.
- `String Representation`: Practice implementing the __str__() method to provide a readable representation of class instances.

By completing this exercise, you will gain experience in using class inheritance, method overriding, and customizing instance representations in Python.

## - ex03: Coffee Machine
In this exercise, you will create a `CoffeeMachine` class with the functionality to serve beverages and handle malfunctions. You will also define an `EmptyCup` class to simulate an empty cup scenario and a custom exception for handling machine breakdowns. The machine will break down after serving a set number of drinks and can be repaired to resume operation.

### Objective
- `Create the CoffeeMachine Class`: Define a class that can serve beverages and handle its breakdown and repair.
- `Create the EmptyCup Class`: Define a class to represent an empty cup as a special case of beverage.
- `Handle Exceptions`: Implement a custom exception for when the machine is broken.
- `Implement Repair and Serve Methods`: Create methods to repair the machine and serve beverages, including handling machine breakdowns and serving empty cups.

### Instructions
#### CoffeeMachine Class:
1. EmptyCup Class:
- Inherit from `HotBeverage`.
- Set the `name` to "empty cup" and `price` to 0.90.
- Implement `describe()` method with the description "An empty cup?! Gimme my money back!".
- Implement `__str__()` method to return a formatted string with name, price, and description.
2. BrokenMachineException Class:
- Inherit from `Exception`.
- Set the exception message to "This coffee machine has to be repaired.".
3. CoffeeMachine Methods:
- `__init__()`: Initialize with a breakdown count of 10.
- `repair()`: Reset the breakdown count to 10 and return a repair confirmation message.
- `serve(drink: HotBeverage)` Serve a beverage or an empty cup randomly. The machine breaks down after serving 10 drinks and raises `BrokenMachineException` when broken.
#### Testing:
- Instantiate the `CoffeeMachine` class.
Use the `serve()` method to serve various drinks (`Coffee`, `Tea`, `Chocolate`, `Cappuccino`) until the machine breaks down.
- Handle the `BrokenMachineException` and repair the machine to resume serving.
- Continue serving drinks and managing the machine's breakdown and repair process.

### Example Usage
When running the machine() function from the machine.py script:
- The CoffeeMachine will attempt to serve drinks until it breaks down after 10 servings.
- An exception will be raised when the machine is broken, and it will be repaired to continue serving.
- Each drink served will be displayed along with the error messages and repair status.

### Learning Points
- `Class Composition`: Learn how to create and use classes within other classes, including nested classes.
- `Exception Handling`: Practice creating and managing custom exceptions for error handling.
- `State Management`: Understand how to manage the state of an object and perform actions based on its state.

By completing this exercise, you will gain experience in managing complex class interactions, handling exceptions, and implementing state-based behavior in Python.

## - ex04: HTML Element Representation
In this exercise, you will create a Python class to represent HTML elements. The `Elem` class will handle the structure and content of HTML elements, allowing you to generate HTML code dynamically. You will also work with a `Text` class to manage text content and escape special characters. The goal is to implement a flexible and reusable solution for generating HTML.

### Objective
- `Create the Elem Class`: This class should handle the representation of HTML elements with support for attributes, content, and different tag types (simple or double).
- `Create the Text Class`: This class extends `str` to handle text content, escape special characters, and format newlines.
- `Handle Exceptions`: Implement custom exceptions to manage errors related to invalid content types.
- `Generate HTML Content`: Use your classes to replicate a specific HTML structure and validate your implementation using provided tests.

### Class Specifications
#### Text Class inherits from str:
- Overrides `__str__()` to escape special characters (`<`, `>`, `"`) and replace newline characters (`\n`) with `<br />`.
- Example"
```
text = Text('"Hello, World!"')
print(text)  # Outputs: &quot;Hello, World!&quot;
```
#### Elem Class
1. Initialization:
- `tag`: The HTML tag name (e.g., `div`, `p`, `a`).
- `attr`: A dictionary of attributes (e.g., `{'class': 'my-class'}`).
- `content`: Content to be included inside the element, which can be a single `Text` or `Elem` object, a list of `Text` or `Elem` objects, or `None`.
- `tag_type`: Indicates if the tag is 'double' (e.g., `<div></div>`) or 'simple' (e.g., `<img />`).
2. Methods:
- `__str__()`: Returns the HTML representation of the element, including attributes and content.
- `add_content(content)`: Adds content to the element. Handles single items or lists.
- `__make_attr()`: Generates a string of HTML attributes.
- `__make_content()`: Formats and returns the HTML content.
3. Exception Handling:
- `ValidationError`: Raised for invalid content types or tag types.

### Example Usage
Here's how you can use the Elem class to create an HTML structure:
```
from elem import Elem, Text

# Create a text element
text = Text('"Hello, World!"')

# Create an HTML structure
html = Elem(tag='html', attr={}, content=[
    Elem(tag='head', attr={}, content=[
        Elem(tag='title', attr={}, content=[text])
    ]),
    Elem(tag='body', attr={}, content=[
        Elem(tag='h1', attr={}, content=[text]),
        Elem(tag='img', attr={'src': 'http://i.imgur.com/pfp3T.jpg'}, tag_type='simple')
    ])
])

# Print the generated HTML
print(html)
```
### Testing
You can validate your implementation by running the provided `test.py` script. This script performs various tests to ensure the correctness of your `Elem` and `Text` classes, including:
- Basic functionality of `Text` and `Elem`.
- Handling empty texts and embedding elements.
- Error cases for invalid content types.
To run the tests:
```
python3 test.py
```
If all tests pass, you should see a message indicating that the tests succeeded.

### Learning Points
- `Class Design`: Learn how to design classes to represent complex structures like HTML elements.
- `String Manipulation`: Practice generating and formatting strings based on dynamic content.
- `Exception Handling`: Understand how to manage and handle exceptions related to invalid input.
By completing this exercise, you'll gain experience in building and managing HTML content programmatically, which is useful for web development and automated content generation.

## - ex05: Specialized HTML Element Classes
In this exercise, you'll extend the HTML element generation functionality by creating specialized classes for various HTML tags. These classes will inherit from the Elem class you created in the previous exercise, simplifying the creation of HTML content and making your code cleaner and more intuitive.

### Objective
- `Create Specialized HTML Classes`: Implement classes for common HTML tags, inheriting from the Elem class.
- `Simplify HTML Generation`: Use these specialized classes to generate HTML content more easily and readably.
- `Demonstrate Usage`: Show how to use these classes to create an HTML structure.

### Specialized HTML Classes
The following classes are derived from `Elem` and represent different HTML elements:
- `Html`: Represents the `<html>` tag.
- `Head`: Represents the `<head>` tag.
- `Body`: Represents the `<body>` tag.
- `Title`: Represents the `<title>` tag.
- `Meta`: Represents the `<meta>` tag (self-closing, i.e., `tag_type='simple'`).
- `Img`: Represents the `<img>` tag (self-closing, i.e., `tag_type='simple'`).
- `Table`: Represents the `<table>` tag.
- `Th`: Represents the `<th>` tag.
- `Tr`: Represents the `<tr>` tag.
- `Td`: Represents the `<td>` tag.
- `Ul`: Represents the `<ul>` tag.
- `Ol`: Represents the `<ol>` tag.
- `Li`: Represents the `<li>` tag.
- `H1`: Represents the `<h1>` tag.
- `H2`: Represents the `<h2>` tag.
- `P`: Represents the `<p>` tag.
- `Div`: Represents the `<div>` tag.
- `Span`: Represents the `<span>` tag.
- `Hr`: Represents the `<hr>` tag (self-closing, i.e., `tag_type='simple'`).
- `Br`: Represents the `<br>` tag (self-closing, i.e., `tag_type='simple'`).
Each class inherits from `Elem` and uses the `super()` function to initialize the parent class with the appropriate tag name and attributes.

### Example Usage
Here's an example of how to use these specialized classes to generate a simple HTML structure:
```
from elements import Html, Head, Body, Title, H1, Img, Text

# Create text content
text = Text('"Hello ground!"')

# Create HTML structure
html = Html([
    Head([
        Title([text])
    ]),
    Body([
        H1([Text('"Oh no, not again!"')]),
        Img(attr={'src': 'http://i.imgur.com/pfp3T.jpg'})
    ])
])

# Print the generated HTML
print(html)
```
This will produce the following HTML output:
```
<html>
  <head>
    <title>"Hello ground!"</title>
  </head>
  <body>
    <h1>"Oh no, not again!"</h1>
    <img src="http://i.imgur.com/pfp3T.jpg" />
  </body>
</html>
```
### Testing
You can test the functionality of these new classes using the elements function in elements.py to verify that they work as expected.
```
def elements():
    text = Text('"Kikou les zouzous"')
    html = Html([
        Head([
            Title([text])
        ]),
        Body([
            H1([text]),
            Img(attr={'src': 'kikou.jpg', 'alt': text})
        ])
    ])
    print(html)

if __name__ == '__main__':
    elements()
```

### Learning Points
- `Class Inheritance`: Learn how to leverage inheritance to create specialized classes that simplify object creation.
- `Code Reusability`: See how inheriting from a base class can reduce code duplication and improve maintainability.
- `HTML Structure`: Gain experience in representing HTML elements programmatically and generating HTML content dynamically.

By completing this exercise, you'll have a set of specialized classes that make generating HTML content much easier and more readable, allowing you to focus on creating the content rather than managing the HTML structure.

## - ex06: HTML Document Validation and Output with the Page Class
In this exercise, you'll enhance your HTML generation system by creating a Page class. This class enforces strict rules on HTML document structure, validates the HTML content, and provides functionality for outputting the HTML to a file. This ensures that your HTML documents conform to specified norms and are correctly structured.

### Objective
- `Implement HTML Validation`: Create a Page class that validates the structure of HTML documents based on defined rules.
- `Generate HTML Output`: Enable the Page class to generate and write HTML content to a file with a proper doctype.
- `Demonstrate Functionality`: Show how the Page class works with examples that cover its validation and file output capabilities.

### Page Class Overview
The Page class is designed to:
1. Validate HTML Structure: Check if the HTML content adheres to predefined rules.
2. Generate HTML Output: Print or write the HTML content to a file with an appropriate doctype.

### Validation Rules
The Page class enforces the following rules:

- `Element Types`: Only specific types are allowed. Invalid element types result in validation errors.
- `Root Element`: An Html element must contain exactly one `Head` and one `Body`.
- `Head Element`: Must contain exactly one `Title` element.
- `Body and Div Elements`: Can only contain specific child elements.
- `Title, H1, H2, Li, Th, Td`: Must contain exactly one `Text` element.
- `P Element`: Must contain only `Text` elements.
- `Span Element`: Can contain `Text` or `P` elements.
- `Ul and Ol Elements`: Must contain at least one `Li` and only `Li` elements.
- `Tr Element`: Must contain at least one `Th` or `Td`, but not both.
- `Table Element`: Must contain only `Tr` elements.

### Functionality
The Page class provides the following features:
- `Validation`: Ensures that HTML documents meet the specified structural rules and constraints.
- `Output`: Writes the HTML content to a file with a doctype, if applicable, for correct HTML formatting.

### Usage
To use the Page class, follow these steps:
- `Create an HTML Document`: Instantiate elements and structure them according to the required rules.
- `Validate the Document`: Use the is_valid() method to check if the document conforms to the rules.
- `Write to File`: If the document is valid, use the write_to_file() method to save it to a file with the appropriate doctype.

### Testing
To ensure the Page class functions correctly:
- `Test Various Structures`: Validate different HTML structures to confirm that all rules are enforced properly.
- `Check File Output`: Verify that the HTML is correctly written to a file with the correct formatting and doctype.

### Learning Points
- `Validation Logic`: Understand how to enforce complex validation rules on hierarchical data structures.
- `HTML Document Handling`: Learn to manage and output HTML documents with constraints.
- `Error Reporting`: Gain experience in detailed error reporting and validation feedback.

By completing this exercise, you’ll have a robust system for generating and validating HTML documents, ensuring that your HTML content adheres to specified rules and is correctly formatted.
